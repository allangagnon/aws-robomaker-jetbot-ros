#!/usr/bin/env python2

import rospy
import json
import csv
import os
import sys
from std_msgs.msg import String
from geometry_msgs.msg import Twist
import rospkg
import time
import urllib

# Name of this ROS package.
ROSAPP='jetbot_app'

# Topics to publish over
CMD_VEL_TOPIC_VEL='cmd_vel'
CMD_VEL_TOPIC_STR='cmd_str'

# Topics to subscribe to
DANCE_ROUTINE_DEMO='/dance/demo'
DANCE_ROUTINE_JSON='/dance/raw'
DANCE_ROUTINE_START='/dance/start'


class Dance():
    '''
    This class will move the JetBot robot according to a defined dance routine. 
    It subscribes to the following topics:

    /dance/demo -- Will pull the routine from /src/jetbot_app/routines folder in this ROS package.
    /dance/start -- The name of the routine stored in the public s3 bucket: s3://jetbot-dance-routines.
    /dance/raw -- A raw JSON string containing the routine.

    Examples:
    rostopic pub /dance/demo std_msgs/String { "routine": "autumn", "start_timestamp": "1607551421" } -- This command will use the routine: {ROS_PACKAGE_SHARE}/routines/autumn.json at timestamp 1607551421.
    rostopic pub /dance/start std_msgs/String { "routine": "autumn", "start_timestamp": "1607551421" } -- This command will use the routine: s3://{S3_BUCKET}/autumn.json at timestamp 1607551421.
    rostopic pub /dance/raw std_msgs/String "{ <DANCE_JSON> }" -- This command will use the raw JSON in the message and start the dance imminently. 

    Routine JSON is the following structure:
    {
        "name": "<DANCE_ROUTINE_NAME>",
        "songName": "<SONG_NAME>",
        "artist": "<ARTIST_NAME>",
        "audioURL": "<URL_TO_AUDIO_FILE>",
        "dancers": {
            "<ROBOT_DANCER_POSITION>": {
                "startPosition": "<START_ROBOT_POSITION>",
                "routine": {
                    "<TIME_STEP_TO_SEND_MOVE>": "<MOVE_COMMAND>",
                }
            }
        }
    }
    '''
    
    def __init__(self, dancer_position, speed, s3_bucket, prefix):
        
        cmd_vel_topic = "/%s/%s" % (prefix, CMD_VEL_TOPIC_VEL)
        cmd_str_topic = "/%s/%s" % (prefix, CMD_VEL_TOPIC_STR)

        # Set constants, setup publishers and subscribe to topics.
        rospy.loginfo("Initializing dance settings...")
        rospy.loginfo("Command topics:")
        rospy.loginfo(" -- Velocity: %s" % cmd_vel_topic)
        rospy.loginfo(" -- String: %s" % cmd_str_topic)
        self.dancer_position = dancer_position
        self.speed = speed
        self.rospack = rospkg.RosPack()
        self.rate = rospy.Rate(self.speed)
        self.twist = Twist()
        self.routine = []
        self.step_counter = 0
        self.routines_s3_bucket = s3_bucket
        self.dancing = False
        self.start_timestamp = None
        
        self._cmd_vel_pub = rospy.Publisher(cmd_vel_topic, Twist, queue_size=1)
        self._cmd_str_pub = rospy.Publisher(cmd_str_topic, String, queue_size=1)        
        rospy.Subscriber(DANCE_ROUTINE_DEMO, String, self.start_demo)
        rospy.Subscriber(DANCE_ROUTINE_JSON, String, self.start_json)
        rospy.Subscriber(DANCE_ROUTINE_START, String, self.start_routine)
    
    def set_routine_array(self, routine):
        # Convert easy JSON document structure into more usable ordered array.
        self.routine = []
        for key, value in routine.items():
            self.routine.append({"step": int(key), "value": value})
        self.routine.sort()
        
    def start_demo(self, data):
        # Start a new demo dance based on local routines in /src/jetbot_app/routines.
        if (not self.dancing):
            meta = json.loads(data.data)
            rospy.loginfo('Dance demo message recieved. Looking up routine: %s' % meta['routine'])
            routines_path = "%s/routines/%s.json" % (self.rospack.get_path("jetbot_app"), meta['routine'])
            rospy.logdebug("Routines path: %s" % routines_path)
            if (os.path.exists(routines_path)):
                with open(routines_path) as f:
                    routine_json = json.load(f) 
                self.set_routine_array(routine_json['dancers'][self.dancer_position]['routine'])
            self.start_timestamp = int(meta['start_timestamp'])
            self.dancing = True
            self.dance(0)
        else:
            rospy.loginfo('Already dancing!')
            
    def start_routine(self, data):
        # Download a public dance routine and run it. 
        if (not self.dancing):
            meta = json.loads(data.data)
            url = "https://%s/%s.json" % (self.routines_s3_bucket, meta['routine'])
            rospy.loginfo('Downloading dance routine: %s' % url)
            response = urllib.urlopen(url)
            routine_json = json.loads(response.read())
            self.set_routine_array(routine_json['dancers'][self.dancer_position]['routine'])
            self.start_timestamp = int(meta['start_timestamp'])
            self.dancing = True
            self.dance(0)
        else:
            rospy.loginfo('Already dancing!')

    def start_json(self, data):
        # Recieve raw JSON from topic /dance/raw and start dance.
        if (not self.dancing):
            rospy.loginfo('JSON Routine recieved: %s' % data.data)
            routine_json = json.loads(data.data)
            self.set_routine_array(routine_json['dancers'][self.dancer_position]['routine'])
            self.start_timestamp = int(time.time())
            self.dancing = True
            self.dance(0)
        else:
            rospy.loginfo('Already dancing!')
            
    def move(self, value):
        # Publish move commands to the move node. If it is a Twist message, use cmd_vel.
        twist = value.split(" ")
        if len(twist) > 2:
            rospy.loginfo('Robot %s: New twist message %s.', self.dancer_position, value)
            self.twist.linear.x = float(twist[0])
            self.twist.linear.y = float(twist[1])
            self.twist.linear.z = float(twist[2])
            self.twist.angular.x = float(twist[3])
            self.twist.angular.y = float(twist[4])
            self.twist.angular.z = float(twist[5])
            self._cmd_vel_pub.publish(self.twist)
            return
        else:
            rospy.loginfo('Robot %s: New move %s.', self.dancer_position, value)
            self._cmd_str_pub.publish(value)
            return
          
    def dance(self, step): 
        # Recursive Dance Step Function, iterates by time step (controlled by SPEED in Hz), then matches current timestep to dance step in the routine.
        # Example: 
        # time step (20) : dance step [3] > { step: 20, value: "left" }, then move left and increment dance step
        # time step (21) : dance step [4] > { step: 23, value: "right"}, NO MATCH : NO CHANGE
        # time step (22) : dance step [4] > { step: 23, value: "right"}, NO MATCH : NO CHANGE
        # time step (23) : dance step [4] > { step: 23, value: "right"}, then move right and increment dance step
        # time step (24) : dance step [5] > { step: 32, value: "forward"}, NO MATCH : NO CHANGE
        next_move = "NO CHANGE"
        if (int(time.time())>=self.start_timestamp):
            if (self.routine[self.step_counter]['step'] == step):
                next_move = self.routine[self.step_counter]['value']
                if (next_move == 'end'):
                    self.dancing = False
                else:
                    self.move(next_move)
                self.step_counter += 1

            rospy.loginfo('Robot time step %i, dance step %i: %s.' % (step, self.step_counter, next_move))
            
            if (self.dancing and self.step_counter < len(self.routine)):
                self.rate.sleep()
                self.dance(step+1)
            else:
                rospy.loginfo('Dance finished!')
                self.move("stop")
                self.step_counter = 0
        else:
            time_left = int(self.start_timestamp-time.time())
            rospy.loginfo('Dance routine invoked. Starting in %i seconds' % time_left)
            self.rate.sleep()
            self.dance(step)

# Main ROS Node
if __name__ == '__main__':
    
    try:
        rospy.init_node('dance')
        # The position, therefore routine, this robot will use.
        dancer_position = rospy.get_param("/dancer_position", "lead")
        # The S3 bucket where the dance routines are stored.
        s3_bucket = rospy.get_param("/s3_bucket", "jetbot-dance-routines.s3-us-west-2.amazonaws.com")
        # The speed to advance dance steps.
        speed = rospy.get_param("/speed", 3)
        prefix = rospy.get_param("/prefix", "move")

        dance = Dance(dancer_position, speed, s3_bucket, prefix)
        rospy.loginfo("Listening for dances...")
        rospy.spin()
        
    except Exception as e:
        rospy.logerr("There was an error: %s" % str(e))